name: 'Bot Setup'
description: 'Performs all common setup steps for bot workflows, including token generation, git config, and dependency installation.'

inputs:
  bot-app-id:
    description: 'The ID of the GitHub App.'
    required: true
  bot-private-key:
    description: 'The private key of the GitHub App.'
    required: true
  opencode-api-key:
    description: 'The default API key, used for providers that do not have one defined in the custom providers JSON.'
    required: false
  opencode-model:
    description: 'The default model to use when custom-providers-json is not configured. Ignored when custom providers are present.'
    required: false
    default: ''
  opencode-fast-model:
    description: 'Optional: The fast model for smaller tasks.'
    required: false
  custom-providers-json:
    description: 'Optional: A JSON string defining custom providers. Use minifier to correctly format.'
    required: false

outputs:
  token:
    description: "The generated GitHub App token."
    value: ${{ steps.generate_token.outputs.token }}
  fallback-models:
    description: "Comma-separated list of models in priority order for fallback rotation"
    value: ${{ steps.export_fallbacks.outputs.models }}

runs:
  using: "composite"
  steps:
    - name: Generate GitHub App Token
      id: generate_token
      uses: actions/create-github-app-token@v1
      with:
        app-id: ${{ inputs.bot-app-id }}
        private-key: ${{ inputs.bot-private-key }}

    - name: Configure Git for Bot
      shell: bash
      env:
        GH_TOKEN: ${{ steps.generate_token.outputs.token }}
      run: |
        git config --global user.name "masusenseibot-agent[bot]"
        git config --global user.email "${{ inputs.bot-app-id }}+masusenseibot-agent@users.noreply.github.com"
        git config --global url."https://x-access-token:${{ steps.generate_token.outputs.token }}@github.com/".insteadOf "https://github.com/"

    - name: Generate OpenCode Configuration
      shell: bash
      env:
        # Pass inputs as environment variables to avoid shell parsing issues
        INPUT_MAIN_MODEL: ${{ inputs.opencode-model }}
        INPUT_FAST_MODEL: ${{ inputs.opencode-fast-model }}
        INPUT_DEFAULT_API_KEY: ${{ inputs.opencode-api-key }}
        INPUT_CUSTOM_PROVIDERS: ${{ inputs.custom-providers-json }}
      run: |
        set -e # Exit immediately if a command fails

        # --- HARDCODED TOGGLE ---
        ADD_REASONING_EFFORT="true"

        mkdir -p ~/.config/opencode

        # --- INPUTS ---
        MAIN_MODEL="${INPUT_MAIN_MODEL}"
        FAST_MODEL="${INPUT_FAST_MODEL}"
        DEFAULT_API_KEY="${INPUT_DEFAULT_API_KEY}"
        CUSTOM_PROVIDERS="${INPUT_CUSTOM_PROVIDERS}"

        # --- DEBUG ---
        echo "DEBUG: MAIN_MODEL length: ${#MAIN_MODEL} chars"
        echo "DEBUG: MAIN_MODEL value: ${MAIN_MODEL:0:30}..."
        echo "DEBUG: CUSTOM_PROVIDERS length: ${#CUSTOM_PROVIDERS} chars"
        echo "DEBUG: CUSTOM_PROVIDERS is set: $( [ -n "$CUSTOM_PROVIDERS" ] && echo 'yes' || echo 'no' )"

        # Validate MAIN_MODEL format
        if [[ "$MAIN_MODEL" == "{"* ]] || [[ "$MAIN_MODEL" == '"{'* ]]; then
          echo "::error::OPENCODE_MODEL secret appears to contain JSON. Expected format: provider/model"
          exit 1
        fi

        # Normalize empty CUSTOM_PROVIDERS
        if [ -z "$CUSTOM_PROVIDERS" ] || [ "$CUSTOM_PROVIDERS" = "" ]; then
          CUSTOM_PROVIDERS='{}'
          echo "DEBUG: CUSTOM_PROVIDERS was empty, using default: {}"
        else
          echo "DEBUG: CUSTOM_PROVIDERS has content"
        fi

        # --- INITIAL CONFIG SETUP ---
        CONFIG='{"$schema": "https://opencode.ai/config.json", "username": "masusenseibot-agent", "autoupdate": true}'

        # Merge custom provider definitions
        if [ "$CUSTOM_PROVIDERS" != "{}" ]; then
          echo "Custom provider definitions found. Merging into configuration."
          CONFIG=$(jq --argjson customProviders "$CUSTOM_PROVIDERS" '. * {provider: $customProviders}' <<< "$CONFIG")
        else
          echo "No custom provider definitions supplied."
        fi

        # --- MODEL RESOLUTION FUNCTION ---
        resolve_primary_model() {
          local custom_providers="$1"
          local fallback_model="$2"
          
          # Case: No custom providers
          if [ -z "$custom_providers" ] || [ "$custom_providers" = "{}" ]; then
            if [ -z "$fallback_model" ]; then
              echo "::error::No model configured. Set CUSTOM_PROVIDERS_JSON or OPENCODE_MODEL."
              exit 1
            fi
            RESOLVED_MODEL="$fallback_model"
            MODEL_SOURCE="opencode_model"
            echo "Model source: OPENCODE_MODEL (no custom providers)"
            return 0
          fi
          
          # Case: Invalid JSON
          if ! echo "$custom_providers" | jq empty 2>/dev/null; then
            echo "::warning::CUSTOM_PROVIDERS_JSON is invalid JSON. Falling back to OPENCODE_MODEL."
            if [ -z "$fallback_model" ]; then
              echo "::error::Invalid CUSTOM_PROVIDERS_JSON and no OPENCODE_MODEL fallback."
              exit 1
            fi
            RESOLVED_MODEL="$fallback_model"
            MODEL_SOURCE="opencode_model"
            return 0
          fi
          
          # Case: Empty object
          local provider_count
          provider_count=$(echo "$custom_providers" | jq 'keys | length')
          if [ "$provider_count" -eq 0 ]; then
            if [ -z "$fallback_model" ]; then
              echo "::error::Empty CUSTOM_PROVIDERS_JSON and no OPENCODE_MODEL."
              exit 1
            fi
            RESOLVED_MODEL="$fallback_model"
            MODEL_SOURCE="opencode_model"
            return 0
          fi
          
          # Extract first provider with models, sorted by model priority
          local resolved
          resolved=$(echo "$custom_providers" | jq -r '
            to_entries
            | map(select(.value.models != null and (.value.models | keys | length) > 0))
            | .[0] as $p
            | if $p then
                ($p.value.models | to_entries | sort_by(.value.priority // 999) | .[0].key) as $m
                | "\($p.key)/\($m)"
              else
                empty
              end
          ')
          
          if [ -z "$resolved" ] || [ "$resolved" = "/" ]; then
            echo "::warning::No providers with models in CUSTOM_PROVIDERS_JSON."
            if [ -z "$fallback_model" ]; then
              echo "::error::No usable models found and no OPENCODE_MODEL fallback."
              exit 1
            fi
            RESOLVED_MODEL="$fallback_model"
            MODEL_SOURCE="opencode_model"
            return 0
          fi
          
          RESOLVED_MODEL="$resolved"
          MODEL_SOURCE="custom_providers"
          echo "Model source: CUSTOM_PROVIDERS_JSON â†’ $RESOLVED_MODEL"
          return 0
        }

        # --- CONFIGURE MODEL FUNCTION ---
        configure_model() {
          local model_string="$1"
          local config_key="$2"
          local provider="${model_string%%/*}"
          local model_name="${model_string#*/}"

          if jq -e --arg provider "$provider" '. | has($provider)' <<< "$CUSTOM_PROVIDERS" >/dev/null; then
            echo "Provider '$provider' found in custom definitions."
            
            if ! jq -e --arg provider "$provider" --arg modelName "$model_name" '.[$provider].models | has($modelName)' <<< "$CUSTOM_PROVIDERS" >/dev/null; then
              echo "::error::Model '$model_name' not found in provider '$provider'. Aborting."
              exit 1
            fi
            
            CONFIG=$(jq --arg key "$config_key" --arg val "$model_string" '.[$key] = $val' <<< "$CONFIG")
          else
            echo "Provider '$provider' not in custom definitions. Configuring as standard provider."
            CONFIG=$(jq --arg key "$config_key" --arg val "$model_string" '.[$key] = $val' <<< "$CONFIG")
            CONFIG=$(jq --arg provider "$provider" --arg apiKey "$DEFAULT_API_KEY" \
              '.provider[$provider].options.apiKey = $apiKey' <<< "$CONFIG")
            
            if [[ "$config_key" == "model" && "$ADD_REASONING_EFFORT" == "true" ]]; then
              echo "Applying reasoning effort to standard provider model."
              CONFIG=$(jq --arg provider "$provider" --arg modelName "$model_name" \
                '.provider[$provider].models[$modelName].options.reasoningEffort = "high"' <<< "$CONFIG")
            fi
          fi
        }

        # --- EXECUTION: RESOLVE THEN CONFIGURE ---
        resolve_primary_model "$CUSTOM_PROVIDERS" "$MAIN_MODEL"
        EFFECTIVE_MAIN_MODEL="$RESOLVED_MODEL"
        echo "DEBUG: Using model: $EFFECTIVE_MAIN_MODEL (source: $MODEL_SOURCE)"
        
        configure_model "$EFFECTIVE_MAIN_MODEL" "model"
        
        if [ -n "$FAST_MODEL" ]; then
          configure_model "$FAST_MODEL" "small_model"
        fi

        # --- FINALIZATION ---
        echo "$CONFIG" > ~/.config/opencode/opencode.json
        echo "Successfully generated OpenCode configuration."

    - name: Export Fallback Models List
      id: export_fallbacks
      shell: bash
      env:
        INPUT_MAIN_MODEL: ${{ inputs.opencode-model }}
        INPUT_CUSTOM_PROVIDERS: ${{ inputs.custom-providers-json }}
      run: |
        # --- Use the same resolution logic for consistency ---
        CUSTOM_PROVIDERS="${INPUT_CUSTOM_PROVIDERS}"
        if [ -z "$CUSTOM_PROVIDERS" ] || [ "$CUSTOM_PROVIDERS" = "{}" ]; then
          CUSTOM_PROVIDERS='{}'
        fi
        
        # Determine effective main model using priority logic
        if [ "$CUSTOM_PROVIDERS" != "{}" ]; then
          # Custom providers configured - extract first model
          EFFECTIVE_MAIN_MODEL=$(echo "$CUSTOM_PROVIDERS" | jq -r '
            to_entries
            | map(select(.value.models != null and (.value.models | keys | length) > 0))
            | .[0] as $provider
            | ($provider.value.models | to_entries | sort_by(.value.priority // 999) | .[0].key) as $model
            | "\($provider.key)/\($model)"
          ')
          
          if [ -z "$EFFECTIVE_MAIN_MODEL" ] || [ "$EFFECTIVE_MAIN_MODEL" = "null/" ] || [ "$EFFECTIVE_MAIN_MODEL" = "/" ]; then
            EFFECTIVE_MAIN_MODEL="$INPUT_MAIN_MODEL"
          fi
        else
          EFFECTIVE_MAIN_MODEL="$INPUT_MAIN_MODEL"
        fi
        
        echo "DEBUG: Effective main model for fallback export: $EFFECTIVE_MAIN_MODEL"
        
        # Extract provider and model name from the effective main model
        PROVIDER="${EFFECTIVE_MAIN_MODEL%%/*}"
        MODEL_NAME="${EFFECTIVE_MAIN_MODEL#*/}"
        
        echo "DEBUG: Main model: $EFFECTIVE_MAIN_MODEL"
        echo "DEBUG: Provider: $PROVIDER"
        echo "DEBUG: Model name: $MODEL_NAME"
        
        # If no custom providers configured, just output the main model
        if [ -z "$INPUT_CUSTOM_PROVIDERS" ] || [ "$INPUT_CUSTOM_PROVIDERS" = "{}" ]; then
          echo "No custom providers configured. Using only primary model."
          echo "models=$EFFECTIVE_MAIN_MODEL" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Check if the provider exists in custom providers
        if ! echo "$INPUT_CUSTOM_PROVIDERS" | jq -e --arg provider "$PROVIDER" 'has($provider)' >/dev/null 2>&1; then
          echo "Provider '$PROVIDER' not found in custom providers. Using only primary model."
          echo "models=$EFFECTIVE_MAIN_MODEL" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Get all models for this provider, sorted by priority (lower = higher priority)
        # Models without priority field default to 999 (tried last)
        # Exclude the primary model from fallbacks since it's always first
        FALLBACKS=$(echo "$INPUT_CUSTOM_PROVIDERS" | jq -r --arg provider "$PROVIDER" --arg primary "$MODEL_NAME" '
          .[$provider].models // {}
          | to_entries
          | map(select(.key != $primary))
          | sort_by(.value.priority // 999)
          | map($provider + "/" + .key)
          | join(",")
        ')
        
        # Primary model first, then fallbacks in priority order
        if [ -n "$FALLBACKS" ]; then
          MODELS_LIST="${EFFECTIVE_MAIN_MODEL},${FALLBACKS}"
          echo "Fallback models configured: $FALLBACKS"
        else
          MODELS_LIST="$EFFECTIVE_MAIN_MODEL"
          echo "No fallback models available for provider '$PROVIDER'"
        fi
        
        echo "models=$MODELS_LIST" >> $GITHUB_OUTPUT
        echo "Model rotation order: $MODELS_LIST"

    - name: Check for Python requirements file
      id: check_requirements_file
      shell: bash
      run: |
        if [ -f requirements.txt ]; then
          echo "exists=true" >> $GITHUB_OUTPUT
        else
          echo "exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Set up uv
      if: steps.check_requirements_file.outputs.exists == 'true'
      uses: astral-sh/setup-uv@v4
      with:
        enable-cache: true
        cache-dependency-glob: "requirements.txt"

    - name: Set up Python with uv
      if: steps.check_requirements_file.outputs.exists == 'true'
      shell: bash
      run: |
        uv python install 3.12
        uv venv --python 3.12

    - name: Install dependencies
      if: steps.check_requirements_file.outputs.exists == 'true'
      shell: bash
      run: |
        source .venv/bin/activate
        uv pip install -r requirements.txt

    - name: Install opencode
      shell: bash
      run: curl -fsSL https://opencode.ai/install | bash

    - name: Ensure opencode directory exists
      shell: bash
      run: mkdir -p /home/runner/.local/share/opencode/project
